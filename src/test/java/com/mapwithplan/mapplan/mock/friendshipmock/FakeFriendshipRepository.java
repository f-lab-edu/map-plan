package com.mapwithplan.mapplan.mock.friendshipmock;

import com.mapwithplan.mapplan.common.exception.ResourceNotFoundException;
import com.mapwithplan.mapplan.friendship.domain.Friendship;
import com.mapwithplan.mapplan.friendship.service.port.FriendshipRepository;
import com.mapwithplan.mapplan.plan.domain.Plan;
import lombok.extern.slf4j.Slf4j;

import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import java.util.concurrent.atomic.AtomicLong;
@Slf4j
public class FakeFriendshipRepository implements FriendshipRepository {

    private final AtomicLong autoGeneratedId = new AtomicLong(0);
    private final List<Friendship> data = new ArrayList<>();
    @Override
    public Friendship createFriendship(Friendship friendship) {

        if(friendship.getId() ==null || friendship.getId() == 0){
            Friendship newFriendship = Friendship.builder()
                    .id(autoGeneratedId.incrementAndGet())
                    .memberId(friendship.getMemberId())
                    .friendMemberId(friendship.getFriendMemberId())
                    .friendNickName(friendship.getFriendNickName())
                    .friendshipDate(friendship.getFriendshipDate())
                    .friendStatus(friendship.getFriendStatus())
                    .build();
            data.add(newFriendship);
            return newFriendship;
        } else{
            data.removeIf(test -> Objects.equals(test.getId(), friendship.getId()));
            data.add(friendship);
            return friendship;
        }
    }

    @Override
    public Optional<Friendship> findById(Long friendshipId) {
        return data.stream().filter(test -> test.getId().equals(friendshipId)).findAny();
    }

    @Override
    public Optional<Friendship> approveFriendship(Long friendshipId) {
        return data.stream()
                .filter(test -> test.getId().equals(friendshipId))
                .findAny().map(test -> {
                    test.approve();
                    return test;
                });

    }

    @Override
    public List<Friendship> findAllByIds(List<Long> friendshipIds) {
        List<Friendship> result = new ArrayList<>();
        log.info("data {}" , data.size());
        for (Long friendshipId : friendshipIds) {
            for (Friendship friendship : data) {
                if (friendship.getId().equals(friendshipId)) {
                    result.add(friendship);
                    break; // ID가 중복될 수 없으므로 찾았으면 중복된 ID는 더 이상 확인할 필요가 없음
                }
            }
        }
        return result;
    }
}
